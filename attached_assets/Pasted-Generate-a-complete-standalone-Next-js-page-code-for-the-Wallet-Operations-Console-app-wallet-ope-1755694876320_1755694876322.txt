Generate a complete, standalone Next.js page code for the Wallet Operations Console (/app/wallet-operations/page.tsx) in the Caesarbot Console application, making it fully functional for managing up to 100 Solana wallets per user. Align with a professional-grade system like the referenced bot (Wallets.tsx, OperationsWallets.tsx), including wallet creation (1-100, with burners), import (priv key base64, label, is_burner), export (CSV of pubkeys/labels/is_burner), transfer (SOL/SPL to single recipient), multisend (SOL/SPL to multiple), and additional features: real-time balance tracking (SOL/SPL via Helius API - use live Helius RPC calls for getBalance and getAssetsByOwner, no mocks), airdrop (devnet only, 1 SOL - use actual connection.requestAirdrop on devnet), fund from main wallet (0.1 SOL default - real transfers via SystemProgram.transfer), consolidate SOL (gather from selected to main - build real multi-transfer tx), deposit SOL (QR/address for external - display pubkey QR with qr-code library, monitor via Helius WebSocket), mixer (random SOL routing for privacy, optional Railgun zk-SNARKs toggle - implement real routing with transfers, integrate Railgun SDK for zk if toggled), quick buy (configurable amount/range for Jupiter swaps - use @jupiter-ag/api for live swaps, no mocks). Integrate with Deploy Console: Store wallets in Supabase for selection in multi-wallet bundling (pubkeys fetched in Deploy for PumpPortal deploys on Pump.fun/LetsBonk.fun with Jito bundling - ensure Supabase realtime sync for live wallet updates).
Use tech stack: Next.js, TailwindCSS (dark theme: bg-black text-yellow-400), Framer Motion (glowing hovers), Zustand (state caching), react-hot-toast (notifications), zod + react-hook-form (validation), @solana/web3.js (Keypair, transactions), @solana/spl-token (transfers), @solana/wallet-adapter-react-ui (hardware signing), @helius/sdk (balances, WebSocket updates - use live wss endpoint for onAccountChange), supabase (storage/realtime - use live postgres_changes for updates), CryptoJS (AES encryption for session data), react-window (lazy table for 100 wallets), @jupiter-ag/api (quick buy swaps - live API calls).
Prerequisites:
- Supabase table 'wallets': { user_wallet: text, pubkey: text primary_key, label: text, is_burner: boolean, token_balances: json }. Enable RLS: user_wallet = auth.uid().
- Add to .env: HELIUS_API_KEY, JUPITER_API_KEY (for swaps).
- Install deps: npm install react-hook-form zod @hookform/resolvers react-hot-toast @solana/web3.js @solana/spl-token @solana/wallet-adapter-react @solana/wallet-adapter-react-ui @helius/sdk crypto-js react-window @jupiter-ag/api qr-code.
Code Structure:
- Root div with theme (p-8 bg-black text-yellow-400).
- Forms: Create (numWallets 1-100, mark as burner checkbox), Import (privKey base64, label, is_burner checkbox), Transfer (from dropdown, toPubkey, amount, tokenMint optional), Multisend (from dropdown, dynamic recipients array: add/remove toPubkey/amount, tokenMint optional).
- Wallet List Table: Columns (Pubkey truncated/copyable, Label, SOL Balance, Token Balances json, Burner Yes/No, Actions: Delete, Fund, Quick Buy, Consolidate, Transfer). Sort/filter/search (pubkey/label/balance). Real-time updates via Supabase subscriptions and Helius WebSocket (onAccountChange for balances). Visual flash for changes (green/red).
- Advanced Operations Drawer: Icons/buttons for Fund Wallets, Consolidate SOL, Transfer Assets, Deposit SOL (with QR code generation), Mixer (modal for each, with form/validation).
- Quick Buy Modal: Config (fixed/range amount, token pair ), executes Jupiter swap, signs with wallet key (prompt priv or hardware).
- Export Button: Download CSV (pubkey,label,is_burner).
- Security: No priv key storage (show once in toast/download during create/import, clear memory). AES encryption (CryptoJS) for session data. Hardware prompts via wallet-adapter. Burners advised (toast: "Use burners for privacy; VPN recommended"). Temporary priv key inputs for signing (cleared after).
- Integration with Deploy: Wallets fetched in Deploy via Supabase query; used for bundling (select up to 5, set buy amounts fixed/random, PumpPortal /api/trade-local for buys, Jito bundle).
- Error/Loading: Zod validation (red errors), toasts for success/errors (Solscan links), spinners during API calls.
- Performance: Lazy-load table/modals (React.lazy), stagger Helius calls (50ms delay), cache balances in Zustand (30s refresh), limit multisend to 50 recipients.
- Responsive: Stack forms/table on mobile; animations for hovers/modals.
- Output complete code with imports, error-handling, devnet/mainnet toggle (dynamic connection endpoint), and scalability for 1000+ users (optimized API calls, Socket.io for broadcasts if needed - implement Socket.io client for Helius updates).
// Note: For production, use PumpPortal /create-wallet for burners (real GET call to generate); add Railgun SDK for mixer privacy toggle (live integration if toggled, else random routing). Ensure all integrations are live: Helius RPC for balances (no mock numbers), Supabase for realtime (no static lists), Jupiter for swaps (real API). No mocks anywhere - fetch and display live data only.