Now build the Caesarbot Console application Wallet Operations page, making it fully functional for managing up to 100 Solana wallets per user. **Focus on live data integration only â€“ no mocks, static lists, or hardcoded data. All wallets/balances must be fetched/saved in real-time using Supabase queries (insert for create/import, select/eq for fetch, update for changes, realtime postgres_changes subscriptions for sync) and Helius API (post to RPC for getBalance/getAssetsByOwner, wss WebSocket for onAccountChange updates). Ensure created/imported wallets save to Supabase and immediately appear in the managed table with live balances; export/copy works with real data.** Align with a professional-grade system like the referenced bot (Wallets.tsx, OperationsWallets.tsx), including wallet creation (1-100, with burners - use @solana/web3.js Keypair.generate(), insert to Supabase), import (priv key base64, label, is_burner - validate Keypair.fromSecretKey, insert to Supabase), export (CSV of pubkeys/labels/is_burner from fetched data), transfer (SOL/SPL to single recipient - build real tx with SystemProgram.transfer or createTransferInstruction, sign/send), multisend (SOL/SPL to multiple - multi-instruction tx), and additional features: real-time balance tracking (SOL via Helius getBalance, SPL via getAssetsByOwner - live post requests, WebSocket onAccountChange for updates), airdrop (devnet only, 1 SOL - real connection.requestAirdrop), fund from main wallet (0.1 SOL default - real SystemProgram.transfer), consolidate SOL (gather from selected to main - real multi-transfer tx), deposit SOL (QR/address for external - generate QR with qr-code, monitor via Helius WebSocket), mixer (random SOL routing for privacy, optional Railgun zk-SNARKs toggle - real transfers or Railgun SDK), quick buy (configurable amount/range for Jupiter swaps - real @jupiter-ag/api calls). Integrate with Deploy Console: Store wallets in Supabase for selection (pubkeys fetched via select/eq in Deploy for PumpPortal deploys on Pump.fun/LetsBonk.fun with Jito bundling - ensure realtime sync so new wallets appear immediately in Deploy).

Use tech stack: Next.js, TailwindCSS (dark theme: bg-black text-yellow-400), Framer Motion (glowing hovers), Zustand (state caching for balances), react-hot-toast (notifications), zod + react-hook-form (validation), @solana/web3.js (Keypair, transactions), @solana/spl-token (transfers), @solana/wallet-adapter-react-ui (hardware signing), @helius/sdk (balances, WebSocket updates - live wss endpoint for onAccountChange), supabase (storage/realtime - live insert/select/update/eq and channel subscriptions), CryptoJS (AES encryption for session data), react-window (lazy table for 100 wallets), @jupiter-ag/api (quick buy swaps - live calls), qr-code (for deposit QR).

Prerequisites:
- Supabase table 'wallets': { user_wallet: text, pubkey: text primary_key, label: text, is_burner: boolean, token_balances: json }. Enable RLS: user_wallet = auth.uid().
- Add to .env: HELIUS_API_KEY, JUPITER_API_KEY (for swaps).
- Install deps: npm install react-hook-form zod @hookform/resolvers react-hot-toast @solana/web3.js @solana/spl-token @solana/wallet-adapter-react @solana/wallet-adapter-react-ui @helius/sdk crypto-js react-window @jupiter-ag/api qr-code.

Code Structure:
- Root div with theme (p-8 bg-black text-yellow-400).
- Devnet toggle checkbox (default true, changes connection endpoint, disables airdrop on mainnet).
- Forms: Create (numWallets 1-100, mark as burner checkbox - live Keypair.generate, insert to Supabase), Import (privKey base64, label, is_burner checkbox - live Keypair.fromSecretKey, insert to Supabase), Transfer (from dropdown from fetched wallets, toPubkey, amount, tokenMint optional - live tx build/sign/send), Multisend (from dropdown, dynamic recipients array: add/remove toPubkey/amount, tokenMint optional - live multi-instruction tx).
- Wallet List Table: Columns (Pubkey truncated/copyable, Label, SOL Balance live from Helius, Token Balances json from Helius, Burner Yes/No, Actions: Delete live update, Airdrop, Fund, Quick Buy, Consolidate, Transfer). Sort/filter/search (pubkey/label/balance). Live updates via Supabase subscriptions (postgres_changes on * for table 'wallets', refetch on change) and Helius WebSocket (onAccountChange for each pubkey to update balances). Visual flash for changes (green/red).
- Advanced Operations Drawer: Icons/buttons for Fund Wallets, Consolidate SOL, Transfer Assets, Deposit SOL (with QR code generation via qr-code), Mixer (modal for each, with form/validation).
- Quick Buy Modal: Config (fixed/range amount, token pair), executes live Jupiter swap, signs with wallet key (prompt priv or hardware).
- Export Button: Download CSV (pubkey,label,is_burner - from live fetched data).
- Security: No priv key storage (show once in toast/download during create/import, clear memory). AES encryption (CryptoJS) for session data. Hardware prompts via wallet-adapter. Burners advised (toast: "Use burners for privacy; VPN recommended"). Temporary priv key inputs for signing (cleared after).
- Integration with Deploy: Wallets fetched in Deploy via Supabase query; used for bundling (select up to 5, set buy amounts fixed/random, PumpPortal /api/trade-local for buys, Jito bundle).
- Error/Loading: Zod validation (red errors), toasts for success/errors (Solscan links), spinners during API calls.
- Performance: Lazy-load table/modals (React.lazy), stagger Helius calls (50ms delay), cache balances in Zustand (30s refresh), limit multisend to 50 recipients.
- Responsive: Stack forms/table on mobile; animations for hovers/modals.
- **Output complete code with imports, error-handling, devnet/mainnet toggle (dynamic connection endpoint), and scalability for 1000+ users (optimized API calls, Socket.io for broadcasts if needed - implement Socket.io client for Helius updates).**
// Note: For production, use PumpPortal /create-wallet for burners (real GET call to generate); add Railgun SDK for mixer privacy toggle (live integration if toggled, else random routing). **Ensure all integrations are live: Helius RPC for balances (no mock numbers, use actual post requests to HELIUS_RPC with env key, WebSocket wss for onAccountChange), Supabase for realtime (no static lists, use live insert/select/update/eq and channel subscriptions for postgres_changes on * for table 'wallets' to refetch on change), Jupiter for swaps (real API calls to @jupiter-ag/api, no mocked responses). No mocks anywhere - fetch, save, and display live data only; throw errors if data isn't real-time or fails to save/fetch; ensure created/imported wallets save to Supabase and appear immediately in table via refetch/subscription.**